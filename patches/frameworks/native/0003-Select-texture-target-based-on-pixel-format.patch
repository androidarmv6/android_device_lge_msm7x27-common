From 2869c4dcc8396a8be56aaed3d5c1752b4482f4f3 Mon Sep 17 00:00:00 2001
From: Pavel Kirpichyov <pavel.kirpichyov@gmail.com>
Date: Mon, 3 Dec 2012 16:12:26 +0400
Subject: [PATCH] Select texture target based on pixel format

Adreno is not optimized for GL_TEXTURE_EXTERNAL_OES, making GPU
utilization (and power), high with GL_TEXTURE_EXTERNAL_OES for
RGB formats.

Change texture target from GL_EXTERNAL_TEXTURE_OES to dynamically
select between GL_EXTERNAL_TEXTURE_OES, and GL_TEXTURE_2D based
on the pixel format.

CM9 original author: Neti Ravi Kumar
CM9-Change-Id: I89ab1d60b23eef55442a9fd338b2a05b3304ce61

Change-Id: Idb32b80c9ee06eb83e9822c1b63adef20828409b
---
 include/gui/SurfaceTexture.h       |    8 ++++++++
 libs/gui/Android.mk                |    6 +++++-
 libs/gui/SurfaceTexture.cpp        |   26 ++++++++++++++++++++++++++
 services/surfaceflinger/Android.mk |    4 ++++
 services/surfaceflinger/Layer.cpp  |   34 +++++++++++++++++++++++++++++++---
 5 files changed, 74 insertions(+), 4 deletions(-)

diff --git a/include/gui/SurfaceTexture.h b/include/gui/SurfaceTexture.h
index 7c519ae..f507994 100644
--- a/include/gui/SurfaceTexture.h
+++ b/include/gui/SurfaceTexture.h
@@ -246,7 +246,11 @@ private:
         virtual ~BufferRejecter() { }
     };
     friend class Layer;
+#ifdef DECIDE_TEXTURE_TARGET
+    status_t updateTexImage(BufferRejecter* rejecter, bool skipSync, bool isComposition=false);
+#else
     status_t updateTexImage(BufferRejecter* rejecter, bool skipSync);
+#endif
 
     // createImage creates a new EGLImage from a GraphicBuffer.
     EGLImageKHR createImage(EGLDisplay dpy,
@@ -338,7 +342,11 @@ private:
     // glCopyTexSubImage to read from the texture.  This is a hack to work
     // around a GL driver limitation on the number of FBO attachments, which the
     // browser's tile cache exceeds.
+#ifdef DECIDE_TEXTURE_TARGET
+    GLenum mTexTarget;
+#else
     const GLenum mTexTarget;
+#endif
 
     // EGLSlot contains the information and object references that
     // SurfaceTexture maintains about a BufferQueue buffer slot.
diff --git a/libs/gui/Android.mk b/libs/gui/Android.mk
index d970a33..5bf5b3b 100644
--- a/libs/gui/Android.mk
+++ b/libs/gui/Android.mk
@@ -55,7 +55,11 @@ ifneq ($(filter generic%,$(TARGET_DEVICE)),)
 endif
 
 ifeq ($(TARGET_BOARD_PLATFORM), msm8960)
-	LOCAL_CFLAGS += -DUSE_NATIVE_FENCE_SYNC
+    LOCAL_CFLAGS += -DUSE_NATIVE_FENCE_SYNC
+endif
+
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
 endif
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/libs/gui/SurfaceTexture.cpp b/libs/gui/SurfaceTexture.cpp
index b4dfb5e..e64a77a 100644
--- a/libs/gui/SurfaceTexture.cpp
+++ b/libs/gui/SurfaceTexture.cpp
@@ -195,7 +195,11 @@ status_t SurfaceTexture::releaseBufferLocked(int buf, EGLDisplay display,
     return err;
 }
 
+#ifdef DECIDE_TEXTURE_TARGET
+status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync, bool isComposition) {
+#else
 status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync) {
+#endif
     ATRACE_CALL();
     ST_LOGV("updateTexImage");
     Mutex::Autolock lock(mMutex);
@@ -254,6 +258,28 @@ status_t SurfaceTexture::updateTexImage(BufferRejecter* rejecter, bool skipSync)
         }
 
         EGLImageKHR image = mEglSlots[buf].mEglImage;
+#ifdef DECIDE_TEXTURE_TARGET
+                // GPU is not efficient in handling GL_TEXTURE_EXTERNAL_OES
+                // texture target. Depending on the image format, decide,
+                // the texture target to be used
+
+                if(isComposition){
+                    switch (mSlots[buf].mGraphicBuffer->format) {
+                        case HAL_PIXEL_FORMAT_RGBA_8888:
+                        case HAL_PIXEL_FORMAT_RGBX_8888:
+                        case HAL_PIXEL_FORMAT_RGB_888:
+                        case HAL_PIXEL_FORMAT_RGB_565:
+                        case HAL_PIXEL_FORMAT_BGRA_8888:
+                        case HAL_PIXEL_FORMAT_RGBA_5551:
+                        case HAL_PIXEL_FORMAT_RGBA_4444:
+                            mTexTarget = GL_TEXTURE_2D;
+                            break;
+                        default:
+                            mTexTarget = GL_TEXTURE_EXTERNAL_OES;
+                            break;
+                    }
+                }
+#endif
         glBindTexture(mTexTarget, mTexName);
         glEGLImageTargetTexture2DOES(mTexTarget, (GLeglImageOES)image);
 
diff --git a/services/surfaceflinger/Android.mk b/services/surfaceflinger/Android.mk
index 5a57697..4278497 100644
--- a/services/surfaceflinger/Android.mk
+++ b/services/surfaceflinger/Android.mk
@@ -42,6 +42,10 @@ ifneq ($(NUM_FRAMEBUFFER_SURFACE_BUFFERS),)
   LOCAL_CFLAGS += -DNUM_FRAMEBUFFER_SURFACE_BUFFERS=$(NUM_FRAMEBUFFER_SURFACE_BUFFERS)
 endif
 
+ifeq ($(BOARD_ADRENO_DECIDE_TEXTURE_TARGET),true)
+    LOCAL_CFLAGS += -DDECIDE_TEXTURE_TARGET
+endif
+
 LOCAL_SHARED_LIBRARIES := \
 	libcutils \
 	libdl \
diff --git a/services/surfaceflinger/Layer.cpp b/services/surfaceflinger/Layer.cpp
index 064f689..d7c8fb5 100644
--- a/services/surfaceflinger/Layer.cpp
+++ b/services/surfaceflinger/Layer.cpp
@@ -347,7 +347,9 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
     }
 
     bool blackOutLayer = isProtected() || (isSecure() && !hw->isSecure());
-
+#ifdef DECIDE_TEXTURE_TARGET
+    GLuint currentTextureTarget = mSurfaceTexture->getCurrentTextureTarget();
+#endif
     if (!blackOutLayer) {
         // TODO: we could be more subtle with isFixedSize()
         const bool useFiltering = getFiltering() || needsFiltering(hw) || isFixedSize();
@@ -358,20 +360,37 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
         mSurfaceTexture->getTransformMatrix(textureMatrix);
 
         // Set things up for texturing.
+#ifdef DECIDE_TEXTURE_TARGET
+	glBindTexture(currentTextureTarget, mTextureName);
+#else
         glBindTexture(GL_TEXTURE_EXTERNAL_OES, mTextureName);
+#endif
         GLenum filter = GL_NEAREST;
         if (useFiltering) {
             filter = GL_LINEAR;
         }
+#ifdef DECIDE_TEXTURE_TARGET
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MAG_FILTER, filter);
+        glTexParameterx(currentTextureTarget, GL_TEXTURE_MIN_FILTER, filter);
+#else
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MAG_FILTER, filter);
         glTexParameterx(GL_TEXTURE_EXTERNAL_OES, GL_TEXTURE_MIN_FILTER, filter);
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadMatrixf(textureMatrix);
         glMatrixMode(GL_MODELVIEW);
         glDisable(GL_TEXTURE_2D);
+#ifdef DECIDE_TEXTURE_TARGET
+        glEnable(currentTextureTarget);
+#else
         glEnable(GL_TEXTURE_EXTERNAL_OES);
+#endif
     } else {
+#ifdef DECIDE_TEXTURE_TARGET
+        glBindTexture(currentTextureTarget, mFlinger->getProtectedTexName());
+#else
         glBindTexture(GL_TEXTURE_2D, mFlinger->getProtectedTexName());
+#endif
         glMatrixMode(GL_TEXTURE);
         glLoadIdentity();
         glMatrixMode(GL_MODELVIEW);
@@ -380,9 +399,12 @@ void Layer::onDraw(const sp<const DisplayDevice>& hw, const Region& clip) const
     }
 
     drawWithOpenGL(hw, clip);
-
+#ifdef DECIDE_TEXTURE_TARGET
+    glEnable(currentTextureTarget);
+#else
     glDisable(GL_TEXTURE_EXTERNAL_OES);
     glDisable(GL_TEXTURE_2D);
+#endif
 }
 
 // As documented in libhardware header, formats in the range
@@ -642,8 +664,14 @@ Region Layer::latchBuffer(bool& recomputeVisibleRegions)
 
 
         Reject r(mDrawingState, currentState(), recomputeVisibleRegions);
-
+#ifdef DECIDE_TEXTURE_TARGET
+        // While calling updateTexImage() from SurfaceFlinger, let it know
+        // by passing an extra parameter
+        // This will be true always.
+        if (mSurfaceTexture->updateTexImage(&r, true, true) < NO_ERROR) {
+#else
         if (mSurfaceTexture->updateTexImage(&r, true) < NO_ERROR) {
+#endif
             // something happened!
             recomputeVisibleRegions = true;
             return outDirtyRegion;
-- 
1.7.10.4

